# Moved schema file to correct folder for Spring Boot GraphQL auto-detection
# (Previously at src/main/resources/schema.graphqls which is NOT auto-scanned)

# Sports Stats GraphQL Schema

scalar Date
scalar DateTime
scalar Long

enum Position {
  POINT_GUARD
  SHOOTING_GUARD
  SMALL_FORWARD
  POWER_FORWARD
  CENTER
}

enum MatchStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
  POSTPONED
}

type Team {
  id: ID!
  name: String!
  city: String!
  foundedYear: Int
  coachName: String
  homeStadium: String
  createdAt: Date
  players: [Player!]!
  matches: [Match!]!
  totalWins: Int!
  totalLosses: Int!
  winPercentage: Float!
}

type Player {
  id: ID!
  firstName: String!
  lastName: String!
  fullName: String!
  jerseyNumber: Int!
  position: Position!
  dateOfBirth: Date
  height: Int
  weight: Int
  team: Team!
  stats: [Stats!]!
  createdAt: Date
  age: Int
  averagePoints: Float!
  averageAssists: Float!
  averageRebounds: Float!
  totalGamesPlayed: Int!
}

type Match {
  id: ID!
  matchDate: DateTime!
  venue: String!
  status: MatchStatus!
  homeTeam: Team!
  awayTeam: Team!
  homeTeamScore: Int
  awayTeamScore: Int
  teams: [Team!]!
  stats: [Stats!]!
  createdAt: DateTime
  winner: Team
  isTie: Boolean!
  totalPoints: Int!
  isFinished: Boolean!
}

type Stats {
  id: ID!
  player: Player!
  match: Match!
  points: Int!
  assists: Int!
  rebounds: Int!
  steals: Int!
  blocks: Int!
  fieldGoalsMade: Int!
  fieldGoalsAttempted: Int!
  threePointersMade: Int!
  threePointersAttempted: Int!
  freeThrowsMade: Int!
  freeThrowsAttempted: Int!
  minutesPlayed: Int
  createdAt: DateTime
  fieldGoalPercentage: Float!
  threePointPercentage: Float!
  freeThrowPercentage: Float!
}

input CreateTeamInput {
  name: String!
  city: String!
  foundedYear: Int
  coachName: String
  homeStadium: String
}

input UpdateTeamInput {
  id: ID!
  name: String
  city: String
  foundedYear: Int
  coachName: String
  homeStadium: String
}

input CreatePlayerInput {
  firstName: String!
  lastName: String!
  jerseyNumber: Int!
  position: Position!
  dateOfBirth: Date
  height: Int
  weight: Int
  teamId: ID!
}

input UpdatePlayerInput {
  id: ID!
  firstName: String
  lastName: String
  jerseyNumber: Int
  position: Position
  dateOfBirth: Date
  height: Int
  weight: Int
  teamId: ID
}

input CreateMatchInput {
  matchDate: DateTime!
  venue: String!
  homeTeamId: ID!
  awayTeamId: ID!
}

input UpdateMatchScoreInput {
  matchId: ID!
  homeTeamScore: Int!
  awayTeamScore: Int!
  status: MatchStatus!
}

input RecordStatsInput {
  playerId: ID!
  matchId: ID!
  points: Int!
  assists: Int!
  rebounds: Int!
  steals: Int!
  blocks: Int!
  fieldGoalsMade: Int!
  fieldGoalsAttempted: Int!
  threePointersMade: Int!
  threePointersAttempted: Int!
  freeThrowsMade: Int!
  freeThrowsAttempted: Int!
  minutesPlayed: Int
}

input PlayerFilter {
  teamId: ID
  position: Position
  minPoints: Int
  maxPoints: Int
  minAge: Int
  maxAge: Int
  minJerseyNumber: Int
  maxJerseyNumber: Int
}

input MatchFilter {
  teamId: ID
  status: MatchStatus
  dateFrom: DateTime
  dateTo: DateTime
  venue: String
  hasScore: Boolean
}

input TeamFilter {
  city: String
  minFoundedYear: Int
  maxFoundedYear: Int
  nameContains: String
  coachName: String
}

enum SortOrder {
  ASC
  DESC
}

input PlayerSort {
  field: PlayerSortField!
  order: SortOrder!
}

enum PlayerSortField {
  FIRST_NAME
  LAST_NAME
  JERSEY_NUMBER
  POINTS
  ASSISTS
  REBOUNDS
}

# Pagination Support
input PaginationInput {
  page: Int = 0
  size: Int = 10
}

enum SortDirection {
  ASC
  DESC
}

input SortInput {
  field: String!
  direction: SortDirection = ASC
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalPages: Int!
  totalElements: Long!
  currentPage: Int!
  pageSize: Int!
}

type TeamConnection {
  content: [Team!]!
  pageInfo: PageInfo!
}

type PlayerConnection {
  content: [Player!]!
  pageInfo: PageInfo!
}

type MatchConnection {
  content: [Match!]!
  pageInfo: PageInfo!
}

type StatsConnection {
  content: [Stats!]!
  pageInfo: PageInfo!
}

type LeaderboardEntry {
  player: Player!
  value: Float!
  rank: Int!
}

type Leaderboard {
  category: String!
  entries: [LeaderboardEntry!]!
  lastUpdated: DateTime!
}

type Query {
  # Existing non-paginated queries
  teams: [Team!]!
  team(id: ID!): Team
  teamByName(name: String!): Team
  teamsByCity(city: String!): [Team!]!
  players(filter: PlayerFilter, sort: PlayerSort, limit: Int): [Player!]!
  player(id: ID!): Player
  playersByTeam(teamId: ID!): [Player!]!
  playersByPosition(position: Position!): [Player!]!
  matches(filter: MatchFilter, limit: Int): [Match!]!
  match(id: ID!): Match
  liveMatches: [Match!]!
  upcomingMatches: [Match!]!
  matchesByTeam(teamId: ID!): [Match!]!
  playerStats(playerId: ID!): [Stats!]!
  matchStats(matchId: ID!): [Stats!]!
  pointsLeaderboard(limit: Int): Leaderboard!
  assistsLeaderboard(limit: Int): Leaderboard!
  reboundsLeaderboard(limit: Int): Leaderboard!
  searchPlayers(name: String!): [Player!]!

  # New paginated queries
  teamsPaginated(pagination: PaginationInput, sort: SortInput): TeamConnection!
  playersPaginated(
    pagination: PaginationInput
    sort: SortInput
  ): PlayerConnection!
  matchesPaginated(
    pagination: PaginationInput
    sort: SortInput
  ): MatchConnection!
  statsPaginated(pagination: PaginationInput, sort: SortInput): StatsConnection!

  # Paginated search and filtering
  searchPlayersPaginated(
    name: String!
    pagination: PaginationInput
    sort: SortInput
  ): PlayerConnection!
  playersByTeamPaginated(
    teamId: ID!
    pagination: PaginationInput
    sort: SortInput
  ): PlayerConnection!
  matchesByTeamPaginated(
    teamId: ID!
    pagination: PaginationInput
    sort: SortInput
  ): MatchConnection!

  # Enhanced filtered queries (with pagination)
  playersFiltered(
    filter: PlayerFilter
    pagination: PaginationInput
    sort: SortInput
  ): PlayerConnection!

  matchesFiltered(
    filter: MatchFilter
    pagination: PaginationInput
    sort: SortInput
  ): MatchConnection!

  teamsFiltered(
    filter: TeamFilter
    pagination: PaginationInput
    sort: SortInput
  ): TeamConnection!
}

type Mutation {
  createTeam(input: CreateTeamInput!): Team!
  updateTeam(input: UpdateTeamInput!): Team!
  deleteTeam(id: ID!): Boolean!
  createPlayer(input: CreatePlayerInput!): Player!
  updatePlayer(input: UpdatePlayerInput!): Player!
  deletePlayer(id: ID!): Boolean!
  createMatch(input: CreateMatchInput!): Match!
  updateMatchScore(input: UpdateMatchScoreInput!): Match!
  startMatch(matchId: ID!): Match!
  endMatch(matchId: ID!): Match!
  recordStats(input: RecordStatsInput!): Stats!
  updateStats(input: RecordStatsInput!): Stats!
}

type Subscription {
  # Live match score updates for a specific match
  matchScoreUpdate(matchId: ID!): Match!

  # All live match updates across all matches
  liveMatchUpdates: Match!

  # Match status changes (SCHEDULED -> LIVE -> COMPLETED)
  matchStatusUpdate(matchId: ID!): Match!

  # Future subscription types
  leaderboardUpdated(category: String!): Leaderboard!
  teamStatsUpdated(teamId: ID!): Team!
}
